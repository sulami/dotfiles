#+STARTUP: show all
* Emacs
** Better defaults
*** Use lexical binding in this file
This org-mode file gets built into an elisp file, and we want this comment at
the top for performance reasons.
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
#+END_SRC
*** Discard the custom file
~custom.el~ is hidden state, all config is declarative.
#+BEGIN_SRC emacs-lisp
(setq custom-file (make-temp-file ""))
#+END_SRC
*** Hide Backups
This way we lose everything backups if the whole machine crashes, but
we don't accidentally leave backups around.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "/tmp/emacs-backup")))
#+END_SRC
*** No trash
#+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash nil)
#+END_SRC
*** Remember recent files
#+BEGIN_SRC emacs-lisp
(when (require 'recentf)
  (recentf-mode 1)
  (setq recentf-max-saved-items 255))
#+END_SRC
*** Be quiet on startup
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      inhibit-startup-screen t
      inhibit-startup-message t)
#+END_SRC
*** Don't ring the bell
#+begin_src emacs-lisp :tangle yes
(setq ring-bell-function 'ignore)
#+end_src
*** Start the scratch buffer empty
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message "")
#+END_SRC
*** Default to Elisp
#+begin_src emacs-lisp :tangle yes
(setq initial-major-mode 'emacs-lisp-mode)
#+end_src
*** Spaces > tabs
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC
*** Show trailing whitespace
#+BEGIN_SRC emacs-lisp
(setq-default show-trailing-whitespace t)
#+END_SRC
*** Highlight matching parens
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC
*** Scrolling
These settings were lifted off the internet™ and make scrolling with pointing
devices feel more reasonable.
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-progressive-speed nil
      mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))
#+END_SRC
*** No line wrapping
At least as a default, much nicer when resizing windows.
#+BEGIN_SRC emacs-lisp
(set-default 'truncate-lines t)
(setq line-move-visual nil)
#+END_SRC
*** UTF-8
#+BEGIN_SRC emacs-lisp
(setq-default buffer-file-coding-system 'utf-8)
(setenv "LANG" "en_be.UTF-8")
(prefer-coding-system 'utf-8)
#+END_SRC
*** Spelling
Use ~aspell~ with British English.
#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "aspell"
      ispell-extra-args (quote ("--sug-mode=ultra" "--lang=en_GB-ise")))
#+END_SRC
*** Y/N for yes or no questions
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Ask before exiting
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC
*** Frame title
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      (list :eval '(let ((p-name (projectile-project-name)))
		     (if (string-equal p-name "-")
			 "Emacs"
		       (concat "Emacs - " p-name)))))
#+END_SRC
*** Disable all the GUI
#+BEGIN_SRC emacs-lisp
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(if (fboundp 'tooltip-mode) (tooltip-mode -1))
#+END_SRC
** macOS
Everything in here relates to macOS in some way.
*** Swap the modifier keys
The MacPorts build I'm using swaps the modifiers from what I'm used to, so I'm
swapping them back.
#+BEGIN_SRC emacs-lisp
(setq mac-command-modifier 'super
      mac-option-modifier 'meta)
#+END_SRC
*** Fix paste
Especially Alfred likes to paste with ~⌘-v~, so that needs to work.
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "s-v") 'yank)
#+END_SRC
*** Fullscreen with ⌘-Return
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "<s-return>") 'toggle-frame-fullscreen)
#+END_SRC
*** Mac font panel
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "s-t") 'mac-font-panel-mode)
#+END_SRC
** Package management
*** use-package
#+BEGIN_SRC emacs-lisp
(setq straight-use-package-by-default t)
#+END_SRC
*** el-patch
Allows for patching functions in packages.
#+begin_src emacs-lisp :tangle yes
(use-package el-patch)
#+end_src
** Appearance
*** Font
Set the font to Fira Code and enable ligatures.
#+BEGIN_SRC emacs-lisp
(let ((font "Fira Code 14"))
  (set-face-attribute 'default nil :font font)
  (set-frame-font font nil t))
;(mac-auto-operator-composition-mode)
#+END_SRC
*** Theme
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :init
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t)
  :config
  (doom-themes-org-config)
  :hook (after-init . (lambda () (load-theme 'doom-one t))))
#+END_SRC
*** All the icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :defer t)
#+END_SRC
*** Modeline
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
 :hook (after-init . doom-modeline-mode)
 :config
 (setq doom-modeline-buffer-file-name-style 'relative-to-project
       doom-modeline-buffer-encoding nil
       doom-modeline-persp-name nil
       doom-modeline-vcs-max-length 36))
#+END_SRC
** Org mode
*** TODO Plain source code blocks
Need to disable ligatures in org-mode because it breaks the asterisks
in org-indent-mode. Almost nothing here works yet.
#+BEGIN_SRC emacs-lisp
;(require 'color)
;(set-face-attribute 'org-block nil :background
                    ;(color-darken-name
                     ;(face-attribute 'default :background) 0))
;(defface org-block-begin-line
  ;'((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
  ;"Face used for the line delimiting the begin of source blocks.")
;
;(defface org-block-background
  ;'((t (:background "#FFFFEA")))
  ;"Face used for the source block background.")
;
;(defface org-block-end-line
  ;'((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
  ;"Face used for the line delimiting the end of source blocks.")

(setq org-src-preserve-indentation nil)
(setq org-edit-src-content-indentation 0)

;(add-hook 'org-mode-hook
;	  (lambda ()
;	    (mac-auto-operator-composition-mode -1)))
#+END_SRC
*** Show emphasis markers
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers nil)
#+END_SRC
*** Indent-mode
#+BEGIN_SRC emacs-lisp
(setq org-indent-indentation-per-level 1)
(add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC
*** Calendar
Weeks start on Monday.
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1)
#+END_SRC
*** TODO org-chef
#+begin_src emacs-lisp :tangle yes
(use-package org-chef
  :disabled)
#+end_src
*** TODO org-jira
#+begin_src emacs-lisp :tangle yes
(use-package org-jira
  :disabled)
#+end_src
** Custom functions
*** Rename buffer file
#+BEGIN_SRC emacs-lisp
(defun sulami/rename-file-and-buffer ()
    "Rename the current buffer and file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (message "Buffer is not visiting a file!")
        (let ((new-name (read-file-name "New name: " filename)))
          (cond
           ((vc-backend filename) (vc-rename-file filename new-name))
           (t
            (rename-file filename new-name t)
            (set-visited-file-name new-name t t)))))))
#+END_SRC
*** Switch to buffer shortcuts
#+BEGIN_SRC emacs-lisp
(defun sulami/open-scratch-buffer ()
  "Open the scratch buffer."
  (interactive)
  (switch-to-buffer "*scratch*"))

(defun sulami/open-message-buffer ()
  "Open the message buffer."
  (interactive)
  (switch-to-buffer "*Messages*"))
#+END_SRC
*** Buffer line count
#+BEGIN_SRC emacs-lisp
(defun sulami/buffer-line-count ()
  "Get the number of lines in the active buffer."
  (count-lines 1 (point-max)))
#+END_SRC
*** Open this file
#+BEGIN_SRC emacs-lisp
(defun sulami/open-emacs-config ()
  "Opens the config file for our favourite OS."
  (interactive)
  (find-file sulami/emacs-config-file))
#+END_SRC
*** Reload this file
#+BEGIN_SRC emacs-lisp
(defun sulami/reload-emacs-config ()
  "Loads the config file for our favourite OS."
  (interactive)
  (org-babel-load-file sulami/emacs-config-file))
#+END_SRC
*** Maximise a window
#+begin_src emacs-lisp :tangle yes
(defun sulami/toggle-maximise-window ()
  "Toggles maximising the current window."
  (interactive)
  (let ((el-reg ?F))
    (if (< winum--window-count 2)
        (jump-to-register el-reg)
      (progn
        (window-configuration-to-register el-reg)
        (delete-other-windows)))))
#+end_src
*** Run a shell command on a region
#+begin_src emacs-lisp :tangle yes
(defun sulami/shell-command-on-region (beg end)
  (interactive "r")
  (if (use-region-p)
      (let ((cmd (read-shell-command "Command: ")))
        (call-process-region beg end cmd t t))
    (message "Select a region first")))
#+end_src
** General
General allows me to use fancy prefix keybindings.

I'm using a spacemacs-inspired system of a global leader key and a local leader
key for major modes. Bindings are setup in the respective ~use-package~
declarations.
#+BEGIN_SRC emacs-lisp
(use-package general
  :config
  (general-auto-unbind-keys)
  (general-evil-setup)
  (defconst leader-key "SPC")
  (general-create-definer leader-def
                          :prefix leader-key
                          :states '(normal visual))
  (defconst local-leader-key ",")
  (general-create-definer local-leader-def
                          :prefix local-leader-key
                          :states '(normal visual))
  (leader-def
   ;; Prefixes
   "b" '(:ignore t :wk "buffer")
   "f" '(:ignore t :wk "file")
   "f e" '(:ignore t :wk "emacs")
   "g" '(:ignore t :wk "git")
   "h" '(:ignore t :wk "help")
   "j" '(:ignore t :wk "jump")
   "k" '(:ignore t :wk "lisp")
   "p" '(:ignore t :wk "project/perspective")
   "s" '(:ignore t :wk "search")
   "t" '(:ignore t :wk "toggle")
   "w" '(:ignore t :wk "window")
   ;; General keybinds
   "$" 'eshell
   "|" 'sulami/shell-command-on-region
   "b e" 'erase-buffer
   "b d" 'kill-this-buffer
   "b m" 'sulami/open-message-buffer
   "b r" 'sulami/rename-file-and-buffer
   "b s" 'sulami/open-scratch-buffer
   "f e e" 'sulami/open-emacs-config
   "f e r" 'sulami/reload-emacs-config
   "h g" 'general-describe-keybindings
   "h k" 'describe-key
   "h l" 'view-lossage
   "t l" 'toggle-truncate-lines
   "t s" 'flyspell-mode
   "t n" 'linum-mode
   "w =" 'balance-windows
   "w m" 'sulami/toggle-maximise-window)
  ;; FIXME this clashes atm
  (general-define-key
   "s-=" 'text-scale-adjust))
#+END_SRC
*** TODO Quick temporary global shortcuts
** Hydra
#+begin_src emacs-lisp :tangle yes
(use-package hydra
  :defer t)
#+end_src
** Evil
#+BEGIN_SRC emacs-lisp
(use-package evil
  :after (general)
  :init
  (setq evil-want-C-u-scroll t
        evil-want-C-i-jump t
        evil-want-Y-yank-to-eol t
        evil-want-keybinding nil)
  :config
  ;; This conflicts with the local leader
  (unbind-key "," evil-motion-state-map)
  :general
  (leader-def
   "<tab>" 'evil-switch-to-windows-last-buffer
   "w d" 'evil-window-delete
   "w h" 'evil-window-move-far-left
   "w j" 'evil-window-move-very-bottom
   "w k" 'evil-window-move-very-top
   "w l" 'evil-window-move-far-right
   "w /" 'evil-window-vsplit
   "w -" 'evil-window-split)
  :hook (after-init . evil-mode))

(use-package evil-collection
  :after (evil flycheck)
  :hook (evil-mode . evil-collection-init))

(use-package evil-search-highlight-persist
  :config
  (defun sulami/isearch-nohighlight ()
    "Remove search highlights if not in the isearch minor mode."
    (interactive)
    (when (not isearch-mode)
      (evil-search-highlight-persist-remove-all)))
  :general
  (general-nmap "RET" 'sulami/isearch-nohighlight)
  :hook (evil-mode . global-evil-search-highlight-persist))

(use-package evil-commentary
  :hook (evil-mode . evil-commentary-mode))

(use-package evil-surround
  :hook (evil-mode . global-evil-surround-mode))
#+END_SRC
** Which key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :hook (after-init . which-key-mode))
#+END_SRC
** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :init
  (setq ivy-on-del-error-function #'ignore
        ivy-count-format "(%d/%d) "
        ivy-re-builders-alist '((counsel-projectile-find-file . ivy--regex-fuzzy)
                                (counsel-apropos . ivy--regex-ignore-order)
                                (t . ivy--regex-plus)))
  :config
  (defun sulami/ivy-with-thing-at-point (cmd)
    "Runs an ivy command with the thing at point."
    (let ((ivy-initial-inputs-alist
           (list
            (cons cmd (thing-at-point 'symbol)))))
      (funcall cmd)))
  :general
  (:keymaps 'ivy-minibuffer-map
   "C-w" 'ivy-backward-kill-word)
  :hook (after-init . ivy-mode))

(use-package counsel
  :config/el-patch
  ;; Patching counsel-apropos to skip the apropos step
  (defun counsel-apropos ()
  "Show all matching symbols.
See `apropos' for further information on what is considered
a symbol and how to search for them."
  (interactive)
  (ivy-read "Search for symbol (word list or regexp): " obarray
            :predicate (lambda (sym)
                         (or (fboundp sym)
                             (boundp sym)
                             (facep sym)
                             (symbol-plist sym)))
            :history 'counsel-apropos-history
            :preselect (ivy-thing-at-point)
            :sort t
            :action
            (el-patch-swap
              ;; Original
              (lambda (pattern)
                (when (string= pattern "")
                  (user-error "Please specify a pattern"))
                ;; If the user selected a candidate form the list, we use
                ;; a pattern which matches only the selected symbol.
                (if (memq this-command '(ivy-immediate-done ivy-alt-done))
                    ;; Regexp pattern are passed verbatim, other input is
                    ;; split into words.
                    (if (string= (regexp-quote pattern) pattern)
                        (apropos (split-string pattern "[ \t]+" t))
                      (apropos pattern))
                  (apropos (concat "\\`" pattern "\\'"))))
              ;; Patch
              (lambda (sym-name)
                (describe-symbol (intern-soft sym-name))
                (select-window (get-buffer-window "*Help*"))))
            :caller 'counsel-apropos))
  :general
  (leader-def
   ":" 'counsel-M-x
   "b b" 'counsel-switch-buffer
   "f f" 'counsel-find-file
   "f r" 'counsel-recentf
   "h a" 'counsel-apropos
   "j i" 'counsel-semantic-or-imenu)
   :hook (after-init . counsel-mode))

(use-package swiper
  :config
  (defun sulami/swiper-thing-at-point ()
    (interactive)
    (sulami/ivy-with-thing-at-point 'swiper))
  :general
  (leader-def
   "s s" 'swiper
   "s S" 'sulami/swiper-thing-at-point))

(use-package ivy-prescient
  :hook (ivy-mode . ivy-prescient-mode)
  :config
  (prescient-persist-mode))

(use-package flx
  :defer t
  :init
  (setq gc-cons-threshold 20000000))
#+END_SRC
** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :general
  (general-imap
   "C-n" nil
   "C-p" nil)
  (:keymaps 'company-active-map
   "C-n" 'company-select-next
   "C-p" 'company-select-previous
   "<S-tab>" nil
   "<tab>" 'company-complete-selection
   "C-w" 'evil-delete-backward-word)
  :hook (after-init . global-company-mode))

(use-package company-prescient
  :hook (company-mode . company-prescient-mode))
#+END_SRC
** Yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :config
  (setq yas-snippet-dirs (cons "/Users/sulami/.emacs/snippets/" yas-snippet-dirs))
  :general
  (:keymaps 'yas-minor-mode-map
   "<tab>" nil
   "TAB" nil
   "<ret>" nil
   "RET" nil)
  :hook (after-init . yas-global-mode))

(use-package ivy-yasnippet
  :general
  (general-imap "C-y" 'ivy-yasnippet))

(use-package yasnippet-snippets
  :defer t
  :after (yasnippet))
#+END_SRC
** Parentheses
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :after (hydra)
  :init
  (require 'smartparens-config)
  (defhydra hydra-wrap (:color blue)
    "wrap"
    ("(" sp-wrap-round)
    ("[" sp-wrap-square)
    ("{" sp-wrap-curly))
  (defhydra hydra-lisp ()
    "lisp"
    ("s" sp-forward-slurp-sexp "slurp")
    ("S" sp-backward-slurp-sexp "slurp backwards")
    ("b" sp-forward-barf-sexp "barf")
    ("B" sp-backward-barf-sexp "barf backwards")
    ("w" hydra-wrap/body "wrap" :color blue)
    ("." nil "quit" :color blue))
  :general
  (leader-def "k" 'hydra-lisp/body)
  :hook (prog-mode . smartparens-global-mode))

(use-package evil-cleverparens
  :hook (prog-mode . evil-cleverparens-mode))
#+END_SRC
** Dumb jump
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :config
  (setq dumb-jump-selector 'ivy
        dumb-jump-force-searcher 'rg)
  :general
  (leader-def
    "j j" 'dumb-jump-go
    "j q" 'dumb-jump-quick-look
    "j p" 'dumb-jump-go-prompt))
#+END_SRC
** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :general
  (general-nmap "s-n" 'avy-goto-word-or-subword-1))
#+END_SRC
** Highlight symbol
I only enable this every now and then.
#+BEGIN_SRC emacs-lisp
(use-package auto-highlight-symbol
  :general
  (leader-def "t h" 'auto-highlight-symbol-mode))
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :init
  (setq projectile-completion-system 'ivy)
  :config
  (defun sulami/projectile-replace ()
    "Search and replace in the whole project."
    (interactive)
    (dired (projectile-project-root) "-alR")
    (let ((file-regex (read-string "Select files with regex: "))
          (from (read-string "Search for: "))
          (to (read-string "Replace with: ")))
      (dired-mark-files-regexp file-regex)
      (dired-do-find-regexp-and-replace from to))
    (projectile-save-project-buffers)
    (with-current-buffer "*xref*"
      (kill-buffer-and-window))
    ; last open file
    (delete-window)
    ; cleanup dired
    (dired-unmark-all-marks)
    (kill-buffer))
  :general
  (leader-def
   "p r" 'sulami/projectile-replace)
  :hook (after-init . projectile-global-mode))

(use-package counsel-projectile
  :defer t
  :config
  (defun sulami/projectile-rg-thing-at-point ()
    (interactive)
    (sulami/ivy-with-thing-at-point 'counsel-projectile-rg))
  :general
  (leader-def
   "p b" 'counsel-projectile-switch-to-buffer
   "p f" 'counsel-projectile-find-file
   "s p" 'counsel-projectile-rg
   "s P" 'sulami/projectile-rg-thing-at-point))
#+END_SRC
** Perspective
#+BEGIN_SRC emacs-lisp
(use-package perspective
  :config
  (setq persp-show-modestring nil)
  :general
  (leader-def
    "p l" 'persp-switch
    "p k" 'persp-kill)
  :hook (after-init . persp-mode))

(use-package persp-projectile
  :defer t
  :after (perspective)
  :general
  (leader-def
    "p p" 'projectile-persp-switch-project))
#+END_SRC
** Winum
#+BEGIN_SRC emacs-lisp
(use-package winum
  :general
  ("s-1" 'winum-select-window-1
   "s-2" 'winum-select-window-2
   "s-3" 'winum-select-window-3
   "s-4" 'winum-select-window-4
   "s-5" 'winum-select-window-5
   "s-6" 'winum-select-window-6
   "s-7" 'winum-select-window-7
   "s-8" 'winum-select-window-8
   "s-9" 'winum-select-window-9
   "s-0" 'winum-select-window-0-or-10)
  :hook (after-init . winum-mode))
#+END_SRC
** Fill column indicator
#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :general
  (leader-def "t i" 'fci-mode))
#+END_SRC
** Focus
#+begin_src emacs-lisp :tangle yes
(use-package focus
  :general
  (leader-def "t f" 'focus-mode))
#+end_src
** Darkroom
#+begin_src emacs-lisp :tangle yes
(use-package darkroom
  :general
  (leader-def "t d" 'darkroom-tentative-mode))
#+end_src
** Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :general
  (leader-def
    "g b" 'magit-blame-addition
    "g s" 'magit-status)
  (:keymaps 'magit-status-mode-map
   "SPC" nil)
  :init
  (setq magit-completing-read-function 'ivy-completing-read))

(use-package evil-magit
  :defer t
  :hook (magit-mode . (lambda () (require 'evil-magit))))

(use-package git-link
  :init
  (defun open-git-link-in-browser ()
    (interactive)
    (let ((git-link-open-in-browser t))
      (git-link "origin" (line-number-at-pos) (line-number-at-pos))))
  (defun open-git-repo-in-browser ()
    (interactive)
    (let ((git-link-open-in-browser t))
      (git-link-homepage "origin")))
  :general
  (leader-def
   "g l" 'git-link
   "g L" 'open-git-link-in-browser
   "g r" 'git-link-homepage
   "g R" 'open-git-repo-in-browser))
#+END_SRC
** Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :config
  ;; Disable flycheck on-the-fly-checking if the line count exceeds 2000.
  (setq flycheck-check-syntax-automatically
        (if (> (sulami/buffer-line-count) 2000)
            (delete 'idle-change flycheck-check-syntax-automatically)
          (add-to-list 'flycheck-check-syntax-automatically 'idle-change)))
  (setq flycheck-global-modes '(not emacs-lisp-mode))
  :general
  (leader-def "t c" 'flycheck-mode)
  :hook (after-init . global-flycheck-mode))
#+END_SRC
** Elisp
#+begin_src emacs-lisp :tangle yes
(local-leader-def
  :keymaps 'emacs-lisp-mode-map
  "e" '(:ignore t :wk "eval")
  "e b" 'eval-buffer
  "e e" 'eval-sexp
  "e f" 'eval-defun
  "e r" 'eval-region)
#+end_src
** Eshell
*** Aliases
#+BEGIN_SRC emacs-lisp
(setq eshell-alias-file "~/.emacs/aliases")
#+END_SRC
** LSP
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :disabled)
(use-package lsp-company
  :disabled)
#+END_SRC
** Clojure
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :defer t
  :after (flycheck-clj-kondo)
  :config
  (require 'flycheck-clj-kondo))

(use-package cider
  :hook (clojure-mode . cider-mode)
  :init
  (setq cider-auto-mode nil)
  :general
  (local-leader-def
    :keymaps 'clojure-mode-map
    "c" 'cider-connect
    "j" 'cider-jack-in
    "q" 'cider-quit
    "s" 'cider-scratch
    "x" 'cider-ns-reload-all
    "e" '(:ignore t :wk "eval")
    "e b" 'cider-eval-buffer
    "e d" 'cider-debug-defun-at-point
    "e e" 'cider-eval-sexp
    "e f" 'cider-eval-defun-at-point
    "e r" 'cider-eval-region
    "h" '(:ignore t :wk "help")
    "h a" 'cider-apropos
    "h d" 'cider-doc
    "h i" 'cider-inspect-last-result
    "h w" 'cider-docview-clojuredocs-web
    "r" '(:ignore t :wk "repl")
    "r f" 'cider-insert-defun-in-repl
    "r n" 'cider-insert-ns-form-in-repl
    "r r" 'cider-switch-to-repl-buffer
    "t" '(:ignore t :wk "test")
    "t b" 'cider-test-show-report
    "t n" 'cider-test-run-ns-tests
    "t p" 'cider-test-run-project-tests
    "t t" 'cider-test-run-test))

(use-package flycheck-clj-kondo
  :defer t)
#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :defer t)
#+END_SRC
** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)))
#+END_SRC
** YAML
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode (("\\.ya?ml\\'" . yaml-mode)))
#+END_SRC
** Protobuf
#+BEGIN_SRC emacs-lisp
(use-package protobuf-mode
  :mode (("\\.proto\\'" . protobuf-mode)))
#+END_SRC
** Done
#+BEGIN_SRC emacs-lisp
(message "Successfully loaded config")
#+END_SRC
