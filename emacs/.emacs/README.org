* Emacs
** Better defaults
*** Use lexical binding in this file
This org-mode file gets built into an elisp file, and we want this comment at
the top for performance reasons.
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
#+END_SRC
*** Discard the custom file
~custom.el~ is hidden state, all config is declarative.
#+BEGIN_SRC emacs-lisp
(setq custom-file (make-temp-file ""))
#+END_SRC
*** Hide Backups
This way we lose everything backups if the whole machine crashes, but
we don't accidentally leave backups around.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "/tmp/emacs-backup")))
#+END_SRC
*** No trash
#+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash nil)
#+END_SRC
*** Remember recent files
#+BEGIN_SRC emacs-lisp
(when (require 'recentf)
  (setq recentf-max-saved-items 255))
#+END_SRC
*** Be quiet on startup
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      inhibit-startup-screen t
      inhibit-startup-message t)
#+END_SRC
*** Start the scratch buffer empty
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message "")
#+END_SRC
*** Spaces > tabs
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC
*** Show trailing whitespace
#+BEGIN_SRC emacs-lisp
(setq show-traling-whitespace t)
#+END_SRC
*** Highlight matching parens
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC
*** Scrolling
These settings were lifted off the internet™ and make scrolling with pointing
devices feel more reasonable.
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-progressive-speed nil
      mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))
#+END_SRC
*** No line wrapping
At least as a default, much nicer when resizing windows.
#+BEGIN_SRC emacs-lisp
(set-default 'truncate-lines t)
(setq line-move-visual nil)
#+END_SRC
*** UTF-8
#+BEGIN_SRC emacs-lisp
(setq-default buffer-file-coding-system 'utf-8)
(setenv "LANG" "en_be.UTF-8")
(prefer-coding-system 'utf-8)
#+END_SRC
*** Spelling
Use ~aspell~ with British English.
#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "aspell"
      ispell-extra-args (quote ("--sug-mode=ultra" "--lang=en_GB-ise")))
#+END_SRC
*** Y/N for yes or no questions
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Ask before exiting
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC
*** Frame title
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      (list :eval '(let ((p-name (projectile-project-name)))
		     (if (string-equal p-name "-")
			 "Emacs"
		       (concat "Emacs - " p-name)))))
#+END_SRC
*** Disable all the GUI
#+BEGIN_SRC emacs-lisp
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(if (fboundp 'tooltip-mode) (tooltip-mode -1))
#+END_SRC
** macOS
Everything in here relates to macOS in some way.
*** Swap the modifier keys
The MacPorts build I'm using swaps the modifiers from what I'm used to, so I'm
swapping them back.
#+BEGIN_SRC emacs-lisp
(setq mac-command-modifier 'super
      mac-option-modifier 'meta)
#+END_SRC
*** Fix paste
Especially Alfred likes to paste with ~⌘-v~, so that needs to work.
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "s-v") 'yank)
#+END_SRC
*** Fullscreen with ⌘-Return
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "<s-return>") 'toggle-frame-fullscreen)
#+END_SRC
*** Mac font panel
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "s-t") 'mac-font-panel-mode)
#+END_SRC
** Package management
*** use-package
#+BEGIN_SRC emacs-lisp
(setq straight-use-package-by-default t)
#+END_SRC
** Appearance
*** Font
Set the font to Fira Code and enable ligatures.
#+BEGIN_SRC emacs-lisp
(let ((font "Fira Code 14"))
  (set-face-attribute 'default nil :font font)
  (set-frame-font font nil t))
;(mac-auto-operator-composition-mode)
#+END_SRC
*** Theme
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :defer t
  :init
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t)
  ;(load-theme 'doom-one t)
  :config
  (doom-themes-org-config))
#+END_SRC
*** All the icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :defer t)
#+END_SRC
*** Modeline
#+BEGIN_SRC emacs-lisp
;(use-package doom-modeline
; :defer t
; :config
; (setq doom-modeline-buffer-file-name-style 'relative-to-project
; doom-modeline-buffer-encoding nil
; doom-modeline-persp-name nil
; doom-modeline-vcs-max-length 36)
; :init
; )
#+END_SRC
** Org mode
*** TODO Plain source code blocks
Need to disable ligatures in org-mode because it breaks the asterisks
in org-indent-mode. Almost nothing here works yet.
#+BEGIN_SRC emacs-lisp
;(require 'color)
;(set-face-attribute 'org-block nil :background
                    ;(color-darken-name
                     ;(face-attribute 'default :background) 0))
;(defface org-block-begin-line
  ;'((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
  ;"Face used for the line delimiting the begin of source blocks.")
;
;(defface org-block-background
  ;'((t (:background "#FFFFEA")))
  ;"Face used for the source block background.")
;
;(defface org-block-end-line
  ;'((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
  ;"Face used for the line delimiting the end of source blocks.")

(setq org-src-preserve-indentation nil)
(setq org-edit-src-content-indentation 0)

;(add-hook 'org-mode-hook
;	  (lambda ()
;	    (mac-auto-operator-composition-mode -1)))
#+END_SRC
*** Show emphasis markers
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers nil)
#+END_SRC
*** Indent-mode
#+BEGIN_SRC emacs-lisp
(setq org-indent-indentation-per-level 1)
(add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC
*** Calendar
Weeks start on Monday.
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1)
#+END_SRC
** Eshell
*** Aliases
#+BEGIN_SRC emacs-lisp
(setq eshell-alias-file "~/.emacs/aliases")
#+END_SRC
** Custom functions
*** Rename buffer file
#+BEGIN_SRC emacs-lisp
(defun sulami/rename-file-and-buffer ()
    "Rename the current buffer and file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (message "Buffer is not visiting a file!")
        (let ((new-name (read-file-name "New name: " filename)))
          (cond
           ((vc-backend filename) (vc-rename-file filename new-name))
           (t
            (rename-file filename new-name t)
            (set-visited-file-name new-name t t)))))))
#+END_SRC
*** Switch to buffer shortcuts
#+BEGIN_SRC emacs-lisp
(defun sulami/open-scratch-buffer ()
  "Open the scratch buffer."
  (interactive)
  (switch-to-buffer "*scratch*"))

(defun sulami/open-message-buffer ()
  "Open the message buffer."
  (interactive)
  (switch-to-buffer "*Messages*"))
#+END_SRC
*** Buffer line count
#+BEGIN_SRC emacs-lisp
(defun sulami/buffer-line-count ()
  "Get the number of lines in the active buffer."
  (count-lines 1 (point-max)))
#+END_SRC
** General
General allows me to use fancy prefix keybindings.

I'm using a spacemacs-inspired system of a global leader key and a local leader
key for major modes. Bindings are setup in the respective ~use-package~
declarations.
#+BEGIN_SRC emacs-lisp
(use-package general
  :config
  (general-auto-unbind-keys)
  (general-evil-setup)
  (defconst leader-key "SPC")
  (general-create-definer leader-def
                          :prefix leader-key
                          :states '(normal visual))
  (defconst local-leader-key ",")
  (general-create-definer local-leader-def
                          :prefix local-leader-key
                          :states '(normal visual))
  (leader-def
   ;; Prefixes
   "b" '(:ignore t :wk "buffer")
   "f" '(:ignore t :wk "file")
   "g" '(:ignore t :wk "git")
   "h" '(:ignore t :wk "help")
   "p" '(:ignore t :wk "project")
   "s" '(:ignore t :wk "search")
   "t" '(:ignore t :wk "toggle")
   "w" '(:ignore t :wk "window")
   ;; General keybinds
   ;; TODO:
   ;; Open this file
   ;; Reload this file
   "b d" 'kill-this-buffer
   "b m" 'sulami/open-message-buffer
   "b r" 'sulami/rename-file-and-buffer
   "b s" 'sulami/open-scratch-buffer
   "h k" 'general-describe-keybindings
   "t l" 'toggle-truncate-lines
   "t n" 'linum-mode))
#+END_SRC
** Evil
#+BEGIN_SRC emacs-lisp
(use-package evil
  :after (general)
  :init
  (setq evil-want-C-u-scroll t
        evil-want-C-i-jump t
        evil-want-Y-yank-to-eol t
        evil-want-keybinding nil)
  :general
  (leader-def
   "w d" 'evil-window-delete
   "w h" 'evil-window-move-far-left
   "w j" 'evil-window-move-very-bottom
   "w k" 'evil-window-move-very-top
   "w l" 'evil-window-move-far-right
   "w /" 'evil-window-vsplit
   "w -" 'evil-window-split)
  :hook
  (after-init . evil-mode))

(use-package evil-collection
  :defer t
  :after (evil flycheck)
  :config
  (evil-collection-init))

(use-package evil-search-highlight-persist
  :config
  (defun sulami/isearch-nohighlight ()
    "Remove search highlights if not in the isearch minor mode."
    (interactive)
    (when (not isearch-mode)
      (evil-search-highlight-persist-remove-all)))
  :general
  (general-nmap "RET" 'sulami/isearch-nohighlight)
  :hook
  (after-init . global-evil-search-highlight-persist))
#+END_SRC
** Which key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :hook
  (after-init . which-key-mode))
#+END_SRC
** Helm
#+BEGIN_SRC emacs-lisp
(use-package helm
  :init
  (setq helm-mode-fuzzy-match t)
  :general
  (leader-def
   ":" 'helm-M-x
   "b b" 'helm-buffers-list
   "f f" 'helm-find-files
   "h a" 'helm-apropos
   "h m" 'helm-man-woman))
(use-package helm-swoop
  :general
  (leader-def "s s" 'helm-swoop))
(use-package helm-rg
  :defer t)
#+END_SRC
** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :config
  (define-key evil-insert-state-map (kbd "C-n") nil)
  (define-key evil-insert-state-map (kbd "C-p") nil)
  (define-key company-active-map (kbd "C-n") 'company-select-next)
  (define-key company-active-map (kbd "C-p") 'company-select-previous)
  (define-key company-active-map (kbd "<S-tab>") nil)
  (define-key company-active-map (kbd "<tab>") 'company-complete-selection)
  (define-key company-active-map (kbd "C-w") 'evil-delete-backward-word)
  :after (evil)
  :hook
  (after-init . global-company-mode))
#+END_SRC
** Yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :config
  (setq yas-snippet-dirs (cons "/Users/sulami/.emacs/snippets/" yas-snippet-dirs))
  :hook
  (after-init . yas-global-mode))

(use-package helm-c-yasnippet
  :general
  (general-imap "C-y" 'helm-yas-complete))

(use-package yasnippet-snippets
  :defer t
  :after (yasnippet))
#+END_SRC
** Parentheses
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :hook (prog-mode . smartparens-global-mode))
  
(use-package evil-cleverparens
  :hook (prog-mode . evil-cleverparens-mode))
#+END_SRC
** Highlight symbol
I only enable this every now and then.
#+BEGIN_SRC emacs-lisp
(use-package auto-highlight-symbol
  :general
  (leader-def
   "t h" 'auto-highlight-symbol-mode))
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :init
  (setq projectile-completion-system 'helm)
  :config
  (defun sulami/projectile-replace ()
    "Search and replace in the whole project."
    (interactive)
    (dired (projectile-project-root) "-alR")
    (let ((file-regex (read-string "Select files with regex: "))
          (from (read-string "Search for: "))
          (to (read-string "Replace with: ")))
      (dired-mark-files-regexp file-regex)
      (dired-do-find-regexp-and-replace from to))
    (projectile-save-project-buffers)
    (with-current-buffer "*xref*"
      (kill-buffer-and-window))
    ; last open file
    (delete-window)
    ; cleanup dired
    (dired-unmark-all-marks)
    (kill-buffer))
  :general
  (leader-def
   "p r" 'sulami/projectile-replace)
  :hook
  (after-init . projectile-global-mode))

(use-package helm-projectile
  :defer t
  :config
  (helm-projectile-on)
  :general
  (leader-def
   "f p" 'helm-projectile
   "s p" 'helm-projectile-rg))
#+END_SRC
** Perspective
#+BEGIN_SRC emacs-lisp
(use-package perspective
  :hook
  (after-init . persp-mode))

(use-package persp-projectile
  :defer t
  :after
  (perspective))
#+END_SRC
** Winum
#+BEGIN_SRC emacs-lisp
(use-package winum
  :bind
  (("s-1" . winum-select-window-1)
   ("s-2" . winum-select-window-2)
   ("s-3" . winum-select-window-3)
   ("s-4" . winum-select-window-4)
   ("s-5" . winum-select-window-5)
   ("s-6" . winum-select-window-6)
   ("s-7" . winum-select-window-7)
   ("s-8" . winum-select-window-8)
   ("s-9" . winum-select-window-9)
   ("s-0" . winum-select-window-0-or-10))
  :hook
  (after-init . winum-mode))
#+END_SRC
** Fill column indicator
#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :general
  (leader-def
   "t f" 'fci-mode))
#+END_SRC
** Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :general
  (leader-def
   "g s" 'magit-status)
  :init
  (setq magit-completing-read-function 'helm-completing-read-1))

(use-package git-link
  :init
  (defun open-git-link-in-browser ()
    (interactive)
    (let ((git-link-open-in-browser t))
      (git-link "origin" (line-number-at-pos) (line-number-at-pos))))
  (defun open-git-repo-in-browser ()
    (interactive)
    (let ((git-link-open-in-browser t))
      (git-link-homepage "origin")))
  :general
  (leader-def
   "g l" 'git-link
   "g L" 'open-git-link-in-browser
   "g r" 'git-link-homepage
   "g R" 'open-git-repo-in-browser))
#+END_SRC
** Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :config
  ;; Disable flycheck on-the-fly-checking if the line count exceeds 2000.
  (setq flycheck-check-syntax-automatically
        (if (> (sulami/buffer-line-count) 2000)
            (delete 'idle-change flycheck-check-syntax-automatically)
          (add-to-list 'flycheck-check-syntax-automatically 'idle-change)))
  :general
  (leader-def "t c" 'flycheck-mode)
  :hook
  (after-init . global-flycheck-mode))
#+END_SRC
** LSP
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :disabled)
(use-package lsp-company
  :disabled)
#+END_SRC
** Clojure
#+BEGIN_SRC emacs-lisp
(use-package flycheck-clj-kondo
  :hook clojure-mode)
(use-package clojure-mode
  :defer t
  :config
  (require 'flycheck-clj-kondo))
(use-package cider
  :hook clojure-mode)
#+END_SRC
** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)))
#+END_SRC
** YAML
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode (("\\.ya?ml\\'" . yaml-mode)))
#+END_SRC
** Protobuf
#+BEGIN_SRC emacs-lisp
(use-package protobuf-mode
  :mode (("\\.proto\\'" . protobuf-mode)))
#+END_SRC
** Done
#+BEGIN_SRC emacs-lisp
(message "Successfully loaded config")
#+END_SRC
