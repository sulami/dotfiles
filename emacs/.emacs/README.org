#+TITLE: Emacs
#+AUTHOR: Robin Schroer
#+CATEGORY: Emacs
#+FILETAGS: side_project yak
#+STARTUP: overview
#+PROPERTY: header-args :results silent

* Use lexical binding in this file
This org-mode file gets built into an elisp file, and we want this comment at
the top for performance reasons.
#+BEGIN_SRC emacs-lisp :tangle yes
;; -*- lexical-binding: t; -*-
#+END_SRC

* Who Am I?
#+begin_src emacs-lisp :tangle yes
(setq user-full-name "Robin Schroer"
      user-login-name "sulami"
      user-mail-address "emacs@sulami.xyz")
#+end_src

* Better defaults

** Discard the custom file
~custom.el~ is hidden state, all config is declarative.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq custom-file (make-temp-file ""))
#+END_SRC

** Hide Backups
This way we lose everything backups if the whole machine crashes, but
we don't accidentally leave backups around.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq backup-directory-alist '(("." . "~/emacs-backup/"))
      auto-save-file-name-transforms '((".*" "~/emacs-auto-save/" t))
      create-lockfiles nil)
#+END_SRC

** Revert changed files
This reloads changed files which are open in Emacs but not edited.
#+begin_src emacs-lisp :tangle yes
(setq revert-without-query '(".*"))
#+end_src

** No trash
#+BEGIN_SRC emacs-lisp :tangle yes
(setq delete-by-moving-to-trash nil)
#+END_SRC

** Remember recent files
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package recentf
  :straight nil
  :custom
  (recentf-max-saved-items 255)
  :hook
  (after-init . recentf-mode))
#+END_SRC

** Be quiet on startup
#+BEGIN_SRC emacs-lisp :tangle yes
(setq inhibit-splash-screen t
      inhibit-startup-screen t
      inhibit-startup-message t)
#+END_SRC

** Don't tell me about keybindings
#+begin_src emacs-lisp :tangle yes
(setq suggest-key-bindings nil)
#+end_src

** Make Tramp great again
These are just fixes to make TRAMP work and be reasonably fast. Mostly
sourced from the internet, I don't pretend to know how this actually
works.
#+begin_src emacs-lisp :tangle yes
(setq tramp-default-method "ssh"
      tramp-ssh-controlmaster-options
      "-o ControlMaster=auto -o ControlPath='tramp.%%C'")

;; Various speedups
;; from https://www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html
(setq remote-file-name-inhibit-cache 3600
      tramp-completion-reread-directory-timeout nil
      vc-ignore-dir-regexp (format "%s\\|%s"
                                   vc-ignore-dir-regexp
                                   tramp-file-name-regexp)
      tramp-verbose 0)

;; Disable the history file on remote hosts
(setq tramp-histfile-override t)

;; Save backup files locally
;; from https://stackoverflow.com/a/47021266
(add-to-list 'backup-directory-alist
             (cons tramp-file-name-regexp "/tmp/emacs-backup/"))
#+end_src

** Remember where we were
#+begin_src emacs-lisp :tangle yes
(require 'saveplace)
(save-place-mode 1)
#+end_src

** Don't ring the bell
#+begin_src emacs-lisp :tangle yes
(setq ring-bell-function 'ignore)
#+end_src

** Don't blink the cursor

I find this mostly distracting.

#+begin_src emacs-lisp :tangle yes
(blink-cursor-mode -1)
#+end_src

** Start the scratch buffer empty
#+BEGIN_SRC emacs-lisp :tangle yes
(setq initial-scratch-message "")
#+END_SRC

** Enable winner-mode
This allows me to use ~winner-undo~ if I accidentally delete a window.
#+begin_src emacs-lisp :tangle yes
(add-hook 'after-init-hook 'winner-mode)
#+end_src

** Default to Elisp
#+begin_src emacs-lisp :tangle yes
(setq initial-major-mode 'emacs-lisp-mode)
#+end_src

** Switch to the help window
#+begin_src emacs-lisp :tangle yes
(setq help-window-select t)
#+end_src

** Spaces > tabs
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default indent-tabs-mode nil)
#+END_SRC

** Sentences end with a single space
#+begin_src emacs-lisp :tangle yes
(setq sentence-end-double-space nil)
#+end_src

** Show trailing whitespace
It's disabled by default, and then gets enabled for all file-based
buffer modes, so not for REPLS and shells.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default show-trailing-whitespace nil)
(defun sulami/show-trailing-whitespace ()
  "Just sets `show-trailing-whitespace'."
  (setq show-trailing-whitespace t))
(add-hook 'prog-mode-hook 'sulami/show-trailing-whitespace)
(add-hook 'text-mode-hook 'sulami/show-trailing-whitespace)
#+END_SRC

** Show empty lines
This shows vim-style tildes on the left fringe.
#+begin_src emacs-lisp :tangle yes
(setq-default indicate-empty-lines t)
(define-fringe-bitmap 'tilde [0 0 0 113 219 142 0 0] nil nil 'center)
(setcdr (assq 'empty-line fringe-indicator-alist) 'tilde)
#+end_src

** Highlight matching parentheses
I prefer this over using rainbow parentheses, which make it difficult
to see what's actually happening.
#+BEGIN_SRC emacs-lisp :tangle yes
(show-paren-mode 1)
#+END_SRC

** Scrolling
These settings were lifted off the internet™ and make scrolling with pointing
devices feel more reasonable.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq mouse-wheel-progressive-speed nil
      mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))
#+END_SRC

** No line wrapping
At least as a default, much nicer when resizing windows.
#+BEGIN_SRC emacs-lisp :tangle yes
(set-default 'truncate-lines t)
(setq line-move-visual nil)
#+END_SRC

** Enable code folding
#+begin_src emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'hs-minor-mode)
#+end_src

** UTF-8
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default buffer-file-coding-system 'utf-8)
(setenv "LANG" "en_US.UTF-8")
(setenv "LC_ALL" "en_US.UTF-8")
(prefer-coding-system 'utf-8)
#+END_SRC

** Spelling
Use ~aspell~ with British English.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq ispell-program-name "aspell"
      ispell-extra-args (quote ("--sug-mode=ultra" "--lang=en_GB-ise")))
#+END_SRC

** Enable erase buffer
#+begin_src emacs-lisp :tangle yes
(put 'erase-buffer 'disabled nil)
#+end_src

** Y/N for yes or no questions
#+BEGIN_SRC emacs-lisp :tangle yes
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Ask before exiting
#+BEGIN_SRC emacs-lisp :tangle yes
(setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

** Frame title
Set the frame title to the current project name. This is useful if I
have several frames/Emacsen open and want to switch between them.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq frame-title-format
      (list :eval '(let ((p-name (projectile-project-name)))
		     (if (string-equal p-name "-")
			 "Emacs"
		       (concat "Emacs - " p-name)))))
#+END_SRC

** Disable all the GUI
#+BEGIN_SRC emacs-lisp :tangle yes
(if (and (fboundp 'tool-bar-mode)
         tool-bar-mode)
    (tool-bar-mode -1))
(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(if (fboundp 'tooltip-mode) (tooltip-mode -1))
#+END_SRC

** Setup SSH via GPG-Agent

This assumes GPG-Agent is already running. Otherwise start it with
~gpg-agent --daemon~.

#+begin_src emacs-lisp :tangle yes
(setenv "SSH_AUTH_SOCK" (string-trim (shell-command-to-string "gpgconf --list-dirs agent-ssh-socket")))
#+end_src

* macOS
Everything in here relates to macOS in some way.

** Swap the modifier keys
The MacPorts build I'm using swaps the modifiers from what I'm used to, so I'm
swapping them back.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq mac-command-modifier 'super
      mac-option-modifier 'meta)
#+END_SRC

** Fix paste
Especially Alfred likes to paste with ~⌘-v~, so that needs to work.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-key global-map (kbd "s-v") 'yank)
#+END_SRC

** Maximise with ⌘-Return
#+BEGIN_SRC emacs-lisp :tangle yes
(define-key global-map (kbd "<s-return>") 'toggle-frame-maximized)
#+END_SRC

** Mac font panel
#+BEGIN_SRC emacs-lisp :tangle yes
(define-key global-map (kbd "s-t") 'mac-font-panel-mode)
#+END_SRC

** Fix frame focus
The MacPorts Emacs version I'm using has the peculiar behaviour that
requires ~menu-bar-mode~ to be enabled in order to focus the current
frame when switching workspaces.
#+begin_src emacs-lisp :tangle yes
;; Use `mac-font-panel-mode' as a proxy to find out if this is the
;; MacPorts version.
(when (fboundp 'mac-font-panel-mode)
  (menu-bar-mode 1))
#+end_src

* Package management

** use-package
Default =straight= to install anything ~use-package~ defines.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq straight-use-package-by-default t)
#+END_SRC

** el-patch
Allows for patching functions in packages.
#+begin_src emacs-lisp :tangle yes
(use-package el-patch)
#+end_src

** Dash
List library that comes in handy.
#+begin_src emacs-lisp :tangle yes
(use-package dash)
#+end_src

** Updating all packages
#+begin_src emacs-lisp :tangle yes
(defun sulami/update-packages ()
  "Prunes and updates packages, revalidates patches."
  (straight-prune-build-directory)
  (straight-pull-all)
  (el-patch-validate-all)
  (straight-freeze-versions)
  (byte-recompile-directory "~/.emacs.d/straight/build" nil 'force))
#+end_src

* Appearance

** Font
Set the font to Fira Code and enable ligatures.

#+BEGIN_SRC emacs-lisp :tangle yes
(let ((font "Fira Code 14"))
  (set-face-attribute 'default nil :font font)
  (set-frame-font font nil t))
(when (boundp 'mac-auto-operator-composition-mode)
  (mac-auto-operator-composition-mode))
#+END_SRC

** Theme
I use =doom-themes=, mostly =doom-solarized-light= & =doom-gruvbox=.

There are some fixes to prevent themes from clashing, and I also
disable most backgrounds as I find them distracting.

#+BEGIN_SRC emacs-lisp :tangle yes
;; I like to live dangerously
(setq custom-safe-themes t)

(defun sulami/disable-all-themes ()
  "Disables all custom themes."
  (interactive)
  (mapc #'disable-theme custom-enabled-themes))

(defun sulami/before-load-theme-advice (theme &optional no-confirm no-enable)
  "Disable all themes before loading a new one.

Prevents mixing of themes, where one theme doesn't override all faces
of another theme."
  (sulami/disable-all-themes))

(advice-add 'load-theme
            :before
            #'sulami/before-load-theme-advice)

(defun sulami/after-load-theme-advice (theme &optional no-confirm no-enable)
  "Unsets backgrounds for some org-mode faces."
  (set-face-background 'outline-1 nil)
  (set-face-background 'org-block nil)
  (set-face-background 'org-block-begin-line nil)
  (set-face-background 'org-block-end-line nil)
  (set-face-background 'org-quote nil))

(advice-add 'load-theme
            :after
            #'sulami/after-load-theme-advice)

(use-package doom-themes
  :after (dash)
  :init
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t)
  :config
  (doom-themes-org-config)
  ;; Set the default colourscheme according to the time of day
  :hook (after-init . (lambda ()
                        (when (display-graphic-p)
                          (let ((hour-of-day (read (format-time-string "%H"))))
                            (if (<= 8 hour-of-day 17)
                                (load-theme 'doom-solarized-light t)
                              (load-theme 'doom-solarized-dark t)))))))
#+END_SRC

** Modeline
I use =doom-modeline=, without any icons, and patched to be regular
height.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package doom-modeline
  :hook (after-init . doom-modeline-mode)
  :custom
  (doom-modeline-icon nil)
  (doom-modeline-height 10)
  (doom-modeline-buffer-file-name-style 'relative-to-project)
  (doom-modeline-buffer-encoding nil)
  (doom-modeline-persp-name nil)
  (doom-modeline-vcs-max-length 36)
  :config/el-patch
  (defun doom-modeline--font-height ()
    "Calculate the actual char height of the mode-line."
    (let ((height (face-attribute 'mode-line :height)))
      ;; WORKAROUND: Fix tall issue of 27 on Linux
      ;; @see https://github.com/seagle0128/doom-modeline/issues/271
      (round
       (* (if (and (>= emacs-major-version 27)
                   (not (eq system-type 'darwin)))
              1.0
            (if doom-modeline-icon
                (el-patch-swap 1.68 1.0)
              (el-patch-swap 1.25 1.0)))
          (cond ((integerp height) (/ height 10))
                ((floatp height) (* height (frame-char-height)))
                (t (frame-char-height))))))))
#+END_SRC

* Custom functions

** Config

*** Open this file
#+BEGIN_SRC emacs-lisp :tangle yes
(defun sulami/open-emacs-config ()
  "Opens the config file for our favourite OS."
  (interactive)
  (find-file sulami/emacs-config-file))
#+END_SRC

*** Reload this file
#+BEGIN_SRC emacs-lisp :tangle yes
(defun sulami/reload-emacs-config ()
  "Loads the config file for our favourite OS."
  (interactive)
  (org-babel-load-file sulami/emacs-config-file))
#+END_SRC

** Buffers

*** Rename buffer file
#+BEGIN_SRC emacs-lisp :tangle yes
(defun sulami/rename-file-and-buffer ()
  "Rename the current buffer and file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer is not visiting a file!")
      (let ((new-name (read-file-name "New name: " filename)))
        (cond
         ((vc-backend filename) (vc-rename-file filename new-name))
         (t
          (rename-file filename new-name t)
          (set-visited-file-name new-name t t)))))))
#+END_SRC

*** Switch to buffer shortcuts
#+BEGIN_SRC emacs-lisp :tangle yes
(defun sulami/open-scratch-buffer ()
  "Opens the scratch buffer."
  (interactive)
  (switch-to-buffer "*scratch*"))

(defun sulami/open-message-buffer ()
  "Opens the message buffer."
  (interactive)
  (switch-to-buffer "*Messages*"))

(defun sulami/open-minibuffer ()
  "Focusses the minibuffer, if active."
  (interactive)
  (when (active-minibuffer-window)
    (select-window (minibuffer-window))))
#+END_SRC

*** Buffer line count
#+BEGIN_SRC emacs-lisp :tangle yes
(defun sulami/buffer-line-count ()
  "Get the number of lines in the active buffer."
  (count-lines 1 (point-max)))
#+END_SRC

*** Delete buffer file
#+begin_src emacs-lisp :tangle yes
(defun sulami/delete-file-and-buffer ()
  "Deletes a buffer and the file it's visiting."
  (interactive)
  (when-let* ((file-name (buffer-file-name))
              (really (yes-or-no-p (format "Delete %s? "
                                           file-name))))
    (delete-file file-name)
    (kill-buffer)))
#+end_src

*** Copy buffer
#+begin_src emacs-lisp :tangle yes
(defun sulami/copy-buffer ()
  "Copies the entire buffer to the kill-ring."
  (interactive)
  (copy-region-as-kill 1 (point-max)))
#+end_src

*** Revert all org-mode buffers
Because I sync most of my org-mode files with my phone, writing to
them without making sure they are current can overwrite changes I've
made. A simple solution is just to attempt to re-read all org-mode
files before certain operations, like refiling.

#+begin_src emacs-lisp :tangle yes
(defun sulami/org-revert-all-org-buffers (&rest _)
  "Reverts all unmodified org-mode buffers."
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when (and (derived-mode-p 'org-mode)
                 (buffer-file-name)
                 (not (buffer-modified-p)))
        (revert-buffer)))))
#+end_src

*** Open the build directory
#+begin_src emacs-lisp :tangle yes
(defun sulami/open-build-dir ()
  (interactive)
  (find-file "~/build"))
#+end_src

** Windows

*** Maximise a window
#+begin_src emacs-lisp :tangle yes
(defun sulami/toggle-maximise-window ()
  "Toggles maximising the current window.

From: https://gist.github.com/mads-hartmann/3402786"
  (interactive)
  (if (and (= 1 (length (window-list)))
           (assoc ?_ register-alist))
      (jump-to-register ?_)
    (progn
      (window-configuration-to-register ?_)
      (delete-other-windows))))
#+end_src

** Run a shell command on a region
#+begin_src emacs-lisp :tangle yes
(defun sulami/shell-command-on-region (beg end)
  (interactive "r")
  (if (use-region-p)
      (let ((cmd (read-shell-command "Command: ")))
        (shell-command-on-region beg end cmd t t))
    (message "Select a region first")))
#+end_src

** Sort words
#+begin_src emacs-lisp :tangle yes
(defun sulami/sort-words (beg end)
  "Sorts words in region."
  (interactive "r")
  (sort-regexp-fields nil "\\w+" "\\&" beg end))
#+end_src

** Toggle narrowing
#+begin_src emacs-lisp :tangle yes
(defun sulami/toggle-narrow ()
  "Toggles `narrow-to-defun' or `org-narrow-to-subtree'."
  (interactive)
  (if (buffer-narrowed-p)
      (widen)
    (if (eq major-mode 'org-mode)
        (org-narrow-to-subtree)
      (narrow-to-defun))))
#+end_src

** Toggle line numbers
This one is faster than ~linum-mode~.
#+begin_src emacs-lisp :tangle yes
(defun sulami/toggle-line-numbers ()
  "Toggles buffer line number display."
  (interactive)
  (setq display-line-numbers (not display-line-numbers)))
#+end_src

** Find the font face used
This one is quite useful for debugging syntax highlighting. It's
adapted from [[https://stackoverflow.com/questions/1242352/get-font-face-under-cursor-in-emacs][here]].
#+begin_src emacs-lisp :tangle yes
(defun sulami/what-face (pos)
  (interactive "d")
  (let ((face (or (get-char-property pos 'read-face-name)
                  (get-char-property pos 'face))))
    (if face
        (message "Face: %s" face)
      (message "No face at %d" pos))))
#+end_src

* General
General allows me to use fancy prefix keybindings.

I'm using a spacemacs-inspired system of a global leader key and a local leader
key for major modes. Bindings are setup in the respective ~use-package~
declarations.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package general
  :config
  (general-auto-unbind-keys)
  (general-evil-setup)
  (defconst leader-key "SPC")
  (general-create-definer leader-def
    :prefix leader-key
    :keymaps 'override
    :states '(normal visual))
  (defconst local-leader-key ",")
  (general-create-definer local-leader-def
    :prefix local-leader-key
    :keymaps 'override
    :states '(normal visual))
  (leader-def
    "" '(nil :wk "my lieutenant general prefix")
    ;; Prefixes
    "a" '(:ignore t :wk "app")
    "b" '(:ignore t :wk "buffer")
    "f" '(:ignore t :wk "file")
    "f e" '(:ignore t :wk "emacs")
    "g" '(:ignore t :wk "git")
    "h" '(:ignore t :wk "help")
    "j" '(:ignore t :wk "jump")
    "k" '(:ignore t :wk "lisp")
    "m" '(:ignore t :wk "mail")
    "o" '(:ignore t :wk "org")
    "p" '(:ignore t :wk "project/perspective")
    "s" '(:ignore t :wk "search/spell")
    "t" '(:ignore t :wk "toggle")
    "w" '(:ignore t :wk "window")
    ;; General keybinds
    "\\" 'indent-region
    "|" 'sulami/shell-command-on-region
    "a c" 'calc
    "a s" 'shell
    "b e" 'erase-buffer
    "b d" 'kill-this-buffer
    "b D" 'kill-buffer-and-window
    "b m" 'sulami/open-message-buffer
    "b ." 'sulami/open-minibuffer
    "b r" 'sulami/rename-file-and-buffer
    "b s" 'sulami/open-scratch-buffer
    "b y" 'sulami/copy-buffer
    "f b" 'sulami/open-build-dir
    "f e e" 'sulami/open-emacs-config
    "f e r" 'sulami/reload-emacs-config
    "f d" 'dired
    "f D" 'sulami/delete-file-and-buffer
    "f R" 'sulami/rename-file-and-buffer
    "h e" 'info-display-manual
    "h g" 'general-describe-keybindings
    "h l" 'view-lossage
    "h m" 'woman
    "h v" 'describe-variable
    "o a" 'org-agenda
    "o c" 'org-capture
    "o i" 'sulami/open-org-inbox
    "t a" 'auto-fill-mode
    "t l" 'toggle-truncate-lines
    "t r" 'refill-mode
    "t s" 'flyspell-mode
    "t n" 'sulami/toggle-line-numbers
    "t N" 'sulami/toggle-narrow
    "w =" 'balance-windows
    "w m" 'sulami/toggle-maximise-window
    "w u" 'winner-undo)
  (general-define-key
   "s-m" 'suspend-frame
   "s-=" (lambda () (interactive) (text-scale-increase 0.5))
   "s--" (lambda () (interactive) (text-scale-decrease 0.5))
   "s-0" (lambda () (interactive) (text-scale-increase 0)))
  ;; Dired
  (general-define-key
   :keymaps 'dired-mode-map
   "<return>" 'dired-find-alternate-file))
#+END_SRC

* Evil
This provides vim-style modal editing. There is quite a bit of
boilerplate to make it work with the various components, but I really
can't stand the default Emacs keybindings.

#+begin_src emacs-lisp :tangle yes
(use-package evil
  :init
  (setq evil-want-C-u-scroll t
        evil-want-C-i-jump t
        evil-want-Y-yank-to-eol t
        evil-want-keybinding nil
        evil-ex-visual-char-range t
        evil-move-beyond-eol t
        evil-split-window-below t
        evil-vsplit-window-right t
        evil-disable-insert-state-bindings t)
  :custom
  (evil-undo-system 'undo-fu)
  :config
  ;; This conflicts with the local leader
  (unbind-key "," evil-motion-state-map)

  (defun sulami/evil-set-jump-wrapper (cmd)
    "Wraps a general command to call `evil-set-jump' before."
    (let ((cmd-name (symbol-name cmd)))
      `((lambda (&rest rest)
          (interactive)
          (evil-set-jump)
          (apply (quote ,cmd) rest))
        :wk ,cmd-name)))

  (defun sulami/evil-shift-left-visual ()
    "`evil-shift-left`, but keeps the selection."
    (interactive)
    (call-interactively 'evil-shift-left)
    (evil-normal-state)
    (evil-visual-restore))

  (defun sulami/evil-shift-right-visual ()
    "`evil-shift-right`, but keeps the selection."
    (interactive)
    (call-interactively 'evil-shift-right)
    (evil-normal-state)
    (evil-visual-restore))

  :general
  (leader-def
   "TAB" 'evil-switch-to-windows-last-buffer
   "<tab>" 'evil-switch-to-windows-last-buffer
   "w d" 'evil-window-delete
   "w h" 'evil-window-move-far-left
   "w j" 'evil-window-move-very-bottom
   "w k" 'evil-window-move-very-top
   "w l" 'evil-window-move-far-right
   "w /" 'evil-window-vsplit
   "w -" 'evil-window-split)
  (general-imap
    "C-w" 'evil-delete-backward-word)
  (general-vmap
    ">" 'sulami/evil-shift-right-visual
    "<" 'sulami/evil-shift-left-visual)
  :hook (after-init . evil-mode))
#+end_src

** evil-collection
This adds evil-keybindings for /a lot/ of popular modes.

I have to disable some because they clash with my own.

#+begin_src emacs-lisp :tangle yes
(use-package evil-collection
  :after (evil)
  :config
  (setq evil-collection-mode-list
        (->> evil-collection-mode-list
             (delete 'company)
             (delete 'gnus)
             (delete 'lispy)))
  (evil-collection-init))
#+end_src

** evil-org
Evil-keybindings for org/agenda.

#+begin_src emacs-lisp :tangle yes
(use-package evil-org
  :after (org)
  :config
  (require 'evil-org-agenda)
  :hook ((org-mode . evil-org-mode)
         (org-agenda-mode . evil-org-agenda-set-keys)))
#+end_src

** evil-commentary
=vim-commentary= but for evil.

#+begin_src emacs-lisp :tangle yes
(use-package evil-commentary
  :hook (evil-mode . evil-commentary-mode))
#+end_src

** evil-surround
=vim-surround= but for evil.

#+begin_src emacs-lisp :tangle yes
(use-package evil-surround
  :hook (evil-mode . global-evil-surround-mode))
#+end_src

** evil-numbers
#+begin_src emacs-lisp :tangle yes
(use-package evil-numbers
  :defer t
  :general
  (general-nvmap
    "C-a" 'evil-numbers/inc-at-pt
    "C-z" 'evil-numbers/dec-at-pt))
#+end_src
* Undo-fu

This just provides linear undo/redo.

#+begin_src emacs-lisp :tangle yes
(use-package undo-fu
  :defer t)
#+end_src

* Which key
This shows all available keybindings when I hit a key. Sometimes
useful.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package which-key
  :hook (after-init . which-key-mode))
#+END_SRC

* Selectrum

#+begin_src emacs-lisp :tangle yes
(use-package selectrum
  ;; :disabled
  :config
  (selectrum-mode +1)
  ;; Load addons.
  (load-file "~/.emacs/lisp/selectrum.el"))

(use-package prescient
  ;; :disabled
  :after (selectrum)
  :config
  (prescient-persist-mode +1)
  ;; (selectrum-prescient-mode +1)
)

(use-package consult
  :defer t)

(use-package mini-frame
  :custom
  (mini-frame-show-parameters '((top . 10)
                                (width . 0.7)
                                (left . 0.5))))

;; (use-package embark)
#+end_src

* Company
Company does completion via a dropdown that automatically pops up
while typing. I can select a match if I want to, but ignore the
dropdown if I don't.

It is disabled in shell-modes, as it crawls directories for
completion, which is bad if you're using TRAMP to connect to a remote
shell.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :init
  (setq company-idle-delay .01
        company-dabbrev-downcase nil)
  :general
  (:keymaps 'company-active-map
   "<tab>" 'company-complete-selection
   "TAB" 'company-complete-selection
   "<ret>" nil
   "<return>" nil
   "RET" nil
   "C-n" 'company-select-next
   "C-p" 'company-select-previous
   "C-w" 'evil-delete-backward-word)
  :hook (prog-mode . company-mode))

(use-package company-prescient
  :hook (company-mode . company-prescient-mode))
#+END_SRC

* Yasnippet
Snippets. I have a few custom ones. =yasnippet-snippets= is a huge
bundle of useful snippets for all kinds of modes.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yasnippet
  :general
  (:keymaps 'yas-minor-mode-map
   "<tab>" nil
   "TAB" nil
   "<ret>" nil
   "RET" nil)
  :config
  (yas-reload-all)
  :hook
  ((text-mode . yas-minor-mode)
   (prog-mode . yas-minor-mode)))

(use-package ivy-yasnippet
  :defer t
  :after (yasnippet)
  :general
  (general-imap "C-y" 'ivy-yasnippet))

(use-package yasnippet-snippets
  :defer t
  :after (yasnippet))
#+END_SRC

* Parentheses
Keeps my parentheses balanced.

** Lispyville
I use [[https://github.com/noctuid/lispyville][LispyVille]] for all Lisp major modes, as it does some additional
magic around spacing, comments, and more.
#+begin_src emacs-lisp :tangle yes
(use-package lispyville
  :defer t
  :custom
  (lispy-close-quotes-at-end-p t)
  :config
  (lispyville-set-key-theme '(operators
                              c-w
                              additional-motions
                              commentary
                              slurp/barf-lispy
                              additional-wrap))
  :general
  (general-imap
    :keymaps 'lispyville-mode-map
    "(" 'lispy-parens
    "[" 'lispy-brackets
    "{" 'lispy-braces
    "\"" 'lispy-quotes
    ")" 'lispy-right-nostring
    "]" 'lispy-right-nostring
    "}" 'lispy-right-nostring
    "DEL" 'lispy-delete-backward-or-splice-or-slurp)
  :hook
  ((emacs-lisp-mode . lispyville-mode)
   (lisp-mode . lispyville-mode)
   (scheme-mode . lispyville-mode)
   (clojure-mode . lispyville-mode)
   (cider-repl-mode . lispyville-mode)
   (monroe-mode . lispyville-mode)
   (racket-mode . lispyville-mode)))
#+end_src

** Electric Pair Mode
All other modes just use ~electric-pair-mode~, which is built into
Emacs already, for automatically matching parentheses. The main reason
for this divide being the whitespace changes done by LispyVille
interfering with non-lisp syntax.

#+begin_src emacs-lisp :tangle yes
(use-package electric-pair-mode
  :straight nil
  :hook
  ((text-mode . electric-pair-local-mode)
   (prog-mode . electric-pair-local-mode)))
#+end_src

* Dumb jump
Uses ~rg~ to jump to definition. Zero setup. Not always correct, but
usually good enough. Much less of a hassle than LSP.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dumb-jump
  :after (evil)
  :config
  (setq dumb-jump-selector 'ivy
        dumb-jump-prefer-searcher 'rg)
  :general
  (leader-def
    "j j" (sulami/evil-set-jump-wrapper 'dumb-jump-go)
    "j p" (sulami/evil-set-jump-wrapper 'dumb-jump-go-prompt)))
#+END_SRC

* Wgrep
This allows running ~rgrep~ and then writing to the result buffer,
modifying the files matched in place. Quite useful for sweeping
changes.
#+begin_src emacs-lisp :tangle yes
(use-package wgrep
  :defer t
  :commands (wgrep-change-to-wgrep-mode)
  :config
  (setq wgrep-auto-save-buffer t)
  :general
  (local-leader-def
    :keymaps 'grep-mode-map
    "w" 'wgrep-change-to-wgrep-mode))
#+end_src

* Highlight TODO
Highlights certain keywords in comments, like =TODO= and =FIXME=.

#+begin_src emacs-lisp :tangle yes
(use-package hl-todo
  :defer t
  :hook (after-init . global-hl-todo-mode))
#+end_src

* Highlight symbol
I only enable this every now and then.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package auto-highlight-symbol
  :custom
  (ahs-idle-interval 0.1)
  :general
  (leader-def "t h" 'auto-highlight-symbol-mode))
#+END_SRC

* Projectile
Manages projects (usually git repositories, but flexible).

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :init
  (setq projectile-completion-system 'ivy)
  :config
  (defun sulami/projectile-replace ()
    "Search and replace in the whole project."
    (interactive)
    (dired (projectile-project-root) "-alR")
    (let ((file-regex (read-string "Select files with regex: "))
          (from (read-string "Search for: "))
          (to (read-string "Replace with: ")))
      (dired-mark-files-regexp file-regex)
      (dired-do-find-regexp-and-replace from to))
    (projectile-save-project-buffers)
    (with-current-buffer "*xref*"
      (kill-buffer-and-window))
    ; last open file
    (delete-window)
    ; cleanup dired
    (dired-unmark-all-marks)
    (kill-buffer))

  (defun sulami/toggle-project-root-shell ()
    "Opens eshell, if possible in the project root."
    (interactive)
    (cond
     ((eq major-mode 'eshell-mode)
      (evil-switch-to-windows-last-buffer))
     ((projectile-project-p)
      (let ((eshell-buffer-name (concat "*eshell-" (projectile-project-name) "*")))
        (projectile-with-default-dir (projectile-project-root)
          (eshell))))
     ((eshell))))

  ;; Don't do projectile stuff on remote files
  ;; from https://github.com/syl20bnr/spacemacs/issues/11381#issuecomment-481239700
  (defadvice projectile-project-root (around ignore-remote first activate)
    (unless (file-remote-p default-directory) ad-do-it))

  :general
  (leader-def
    "p c" 'projectile-compile-project
    "p r" 'sulami/projectile-replace
    "p d" 'projectile-dired)
  ("s-'" 'sulami/toggle-project-root-shell)
  :hook (after-init . projectile-global-mode))

(use-package counsel-projectile
  :defer t
  :init
  (setq projectile-switch-project-action 'counsel-projectile-find-file)
  :config
  (defun sulami/projectile-rg-thing-at-point ()
    (interactive)
    (let ((counsel-projectile-rg-initial-input (thing-at-point 'symbol)))
      (counsel-projectile-rg)))
  :general
  (leader-def
   "p f" 'counsel-projectile-find-file
   "s p" 'counsel-projectile-rg
   "s P" 'sulami/projectile-rg-thing-at-point))

#+END_SRC

* Perspective
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package perspective
  :config
  (setq persp-show-modestring nil)
  :general
  (leader-def
    "p l" 'persp-switch
    "p b" 'persp-counsel-switch-buffer)
  :hook (after-init . persp-mode))

(use-package persp-projectile
  :defer t
  :after (perspective)
  :init
  (defun sulami/kill-project-perspective ()
    "Kills the current project and then the perspective."
    (interactive)
    (when (projectile-project-p)
      (projectile-kill-buffers))
    (let ((pname (persp-name (persp-curr))))
      (when (and (not (eq "main" pname))
                 (yes-or-no-p (format "Kill perspective %s?"pname)))
        (persp-kill pname)
        (message "Killed perspective %s" pname))))
  :general
  (leader-def
    "p p" 'projectile-persp-switch-project
    "p k" 'sulami/kill-project-perspective))
#+END_SRC

* Winum
Number windows and allow me to switch to them.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package winum
  :general
  ("s-1" 'winum-select-window-1
   "s-2" 'winum-select-window-2
   "s-3" 'winum-select-window-3
   "s-4" 'winum-select-window-4
   "s-5" 'winum-select-window-5
   "s-6" 'winum-select-window-6
   "s-7" 'winum-select-window-7
   "s-8" 'winum-select-window-8
   "s-9" 'winum-select-window-9)
  (leader-def
    "w 1" 'winum-select-window-1
    "w 2" 'winum-select-window-2
    "w 3" 'winum-select-window-3
    "w 4" 'winum-select-window-4
    "w 5" 'winum-select-window-5
    "w 6" 'winum-select-window-6
    "w 7" 'winum-select-window-7
    "w 8" 'winum-select-window-8
    "w 9" 'winum-select-window-9)
  :hook (after-init . winum-mode))
#+END_SRC

* Org mode
#+begin_src emacs-lisp :tangle yes
(use-package org
  :config
  (defun sulami/org-return ()
    "`org-return' with better plain list handling.

If inside a plain list, insert a new list item. If the current list
item is empty, remove it instead. Essentially imitating Google Docs."
    (interactive)
    (if (org-at-item-p)
        (let* ((begin (org-in-item-p))
               (struct (org-list-struct))
               (end (org-list-get-item-end begin struct))
               (indent (org-list-get-ind begin struct))
               (bullet (org-list-get-bullet begin struct))
               (checkbox (org-list-get-checkbox begin struct))
               (type (org-list-get-list-type begin
                                             struct
                                             (org-list-prevs-alist struct)))
               ;; Different factors alter the amount of whitespace.
               (whitespace (+ 1
                              (if checkbox 1 0)
                              (if (equal 'descriptive type) 3 0)
                              (if (and checkbox
                                       (equal 'descriptive type))
                                1 0))))
          (if (zerop (- end
                        begin
                        indent
                        (length bullet)
                        (length checkbox)
                        whitespace))
              (progn (org-list-delete-item begin struct)
                     (insert "\n")
                     (backward-char))
            (evil-org-open-below 0)))
      (org-return)))
  :general
  (local-leader-def
    :keymaps 'org-mode-map
    :states '(normal)
    "a" 'org-archive-subtree
    "d" 'org-deadline
    "e" '(org-export-dispatch :wk "org-export-dispatch")
    "f" 'org-fill-paragraph
    "l" 'org-insert-link
    "L" 'org-store-link
    "r" '(org-refile :wk "org-refile")
    "R" 'sulami/org-refile-in-current-file
    "s" 'org-schedule
    "S" 'org-babel-switch-to-session
    "T" 'org-babel-tangle
    "w" 'org-todo
    "W" '((lambda ()
            (interactive)
            (org-todo '(4)))
          :wk "org-todo (with note)"))
  ;; Fix plain lists.
  (general-imap
    :keymaps 'org-mode-map
    "RET" 'sulami/org-return))
#+end_src

** Add more workflow states
#+begin_src emacs-lisp :tangle yes
(setq org-todo-keywords
      '((sequence "TODO(t)" "WIP(p)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)"))
      org-use-fast-todo-selection t)
#+end_src

** Save when I change a workflow state
#+begin_src emacs-lisp :tangle yes
(setq org-log-into-drawer t)

(add-hook 'org-trigger-hook 'save-buffer)
#+end_src

** Footnotes
Define them at the end of the current outline section, and
automatically renumber them when they're modified.
#+begin_src emacs-lisp :tangle yes
(setq org-footnote-section nil
      org-footnote-auto-adjust t)
#+end_src

** Plain source code blocks
#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-src-preserve-indentation nil
      org-edit-src-content-indentation 0)
#+END_SRC

** Open source code blocks in the same window
#+begin_src emacs-lisp :tangle yes
(setq org-src-window-setup 'current-window)
#+end_src

** Enable babel for more languages
#+begin_src emacs-lisp :tangle yes
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (shell . t)
   (python . t)))
#+end_src

** Use drawers for source block evaluation
#+begin_src emacs-lisp :tangle yes
(add-to-list 'org-babel-default-header-args '(:results . "replace drawer"))
#+end_src

** Disable ligatures in org-mode
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'org-mode-hook
          (lambda ()
            (auto-composition-mode -1)))
#+END_SRC

** Show emphasis markers
#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-hide-emphasis-markers nil)
#+END_SRC

** Indent-mode
#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-indent-indentation-per-level 1)
(add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

** Enable spell checking
#+begin_src emacs-lisp :tangle yes
(add-hook 'org-mode-hook 'flyspell-mode)
#+end_src

** Archiving
- archive into one shared file
- auto-save
#+begin_src emacs-lisp :tangle yes
(setq org-archive-location "~/Documents/Notes/archive.org::"
      org-archive-subtree-add-inherited-tags t)

(advice-add 'org-refile :before 'sulami/org-revert-all-org-buffers)

(advice-add 'org-archive-subtree :after 'org-save-all-org-buffers)
#+end_src

** Tags
Autocomplete tags using all agenda files.
#+begin_src emacs-lisp :tangle yes
(setq org-complete-tags-always-offer-all-agenda-tags t)
#+end_src

** Export
Set some sane default options for exporting.
#+begin_src emacs-lisp :tangle yes
(setq org-export-with-toc nil
      org-export-initial-scope 'subtree)
#+end_src

** Calendar
Weeks start on Monday, and who thought MDY was a good idea?
#+BEGIN_SRC emacs-lisp :tangle yes
(setq calendar-week-start-day 1
      calendar-date-style 'iso)
#+END_SRC

** org-gfm
This gives me org-mode->github flavoured markdown export.
#+begin_src emacs-lisp :tangle yes
(use-package ox-gfm
  :defer 3
  :after org)
#+end_src

* Magit
This is probably the single best interface for Git out there.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (magit-git-executable "/run/current-system/sw/bin/git")
  (magit-completing-read-function #'ivy-completing-read)
  :config
  (defun sulami/magit-rebase-master ()
    (interactive)
    (magit-git-command-topdir "git pull origin master:master")
    (magit-rebase-branch "master" '()))
  (transient-append-suffix 'magit-rebase "e" '(sulami/magit-rebase-master
                                             :key "m"
                                             :description "Pull & rebase master"))
  :general
  (leader-def
    "g b" 'magit-blame-addition
    "g s" 'magit-status)
  :hook
  ((shell-mode . with-editor-export-editor)
   (term-mode . with-editor-export-editor)
   (eshell-mode . with-editor-export-editor)
   (git-commit-setup . git-commit-turn-on-flyspell)))

(use-package evil-magit
  :defer t
  :hook (magit-mode . (lambda () (require 'evil-magit))))

#+END_SRC

** Git link
This package gets me the link to a git repository or line in a file.

#+begin_src emacs-lisp :tangle yes
(use-package git-link
  :init
  (defun open-git-link-in-browser ()
    (interactive)
    (let ((git-link-open-in-browser t))
      (git-link "origin" (line-number-at-pos) (line-number-at-pos))))
  (defun open-git-repo-in-browser ()
    (interactive)
    (let ((git-link-open-in-browser t))
      (git-link-homepage "origin")))
  :general
  (leader-def
   "g l" 'git-link
   "g L" 'open-git-link-in-browser
   "g r" 'git-link-homepage
   "g R" 'open-git-repo-in-browser))
#+end_src

* Flycheck
Flycheck does automatic linting. I enable it mostly manually, as I
don't have a lot of linters setup.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck
  :config
  ;; Disable flycheck on-the-fly-checking if the line count exceeds 2000.
  (setq flycheck-check-syntax-automatically
        (if (> (sulami/buffer-line-count) 2000)
            (delete 'idle-change flycheck-check-syntax-automatically)
          (add-to-list 'flycheck-check-syntax-automatically 'idle-change)))
  :custom
  (flycheck-emacs-lisp-load-path 'inherit)
  :general
  (leader-def "t c" 'flycheck-mode)
  :hook (clojure-mode . flycheck-mode))
#+END_SRC

* Emacs Lisp
Just some bindings for interacting with Emacs Lisp.

#+begin_src emacs-lisp :tangle yes
(local-leader-def
  :keymaps 'emacs-lisp-mode-map
  "e" '(:ignore t :wk "eval")
  "e b" 'eval-buffer
  "e e" 'eval-last-sexp
  "e f" 'eval-defun
  "e r" 'eval-region)
#+end_src

* Eshell
Eshell is my main shell these days, mostly because it integrates so
well with Emacs. On rare occasions I use a terminal emulator (usually
also inside Emacs) with zsh.

** Aliases
This just loads my aliases. They are auto-generated from my zsh
aliases, so that the two are always in sync.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq eshell-aliases-file "~/.emacs/aliases")
#+END_SRC

** Completion
Eshell doesn't do context-aware autocompletion by default and defaults
to completing filenames instead. Luckily we can easily define custom
completion handlers for commands.

*** Disable the completion buffer
This swaps the terrible popup buffer that eshell opens when I hit
=TAB= for a ivy-based completion.

I also disable company-mode in eshell, because it doesn't play nice
with TRAMP.

The binding has to happen here in a hook because ~eshell-mode-map~
isn't available before eshell is started.

#+begin_src emacs-lisp :tangle yes
(add-hook
 'eshell-mode-hook
 (lambda ()
   (setq completion-at-point-functions '(comint-completion-at-point t))
   (define-key eshell-mode-map (kbd "TAB") 'completion-at-point)
   (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)))
#+end_src

*** Sudo
#+begin_src emacs-lisp :tangle yes
(defun pcomplete/sudo ()
  "Completion rules for the `sudo' command."
  (let ((pcomplete-ignore-case t))
    (pcomplete-here (funcall pcomplete-command-completion-function))
    (while (pcomplete-here (pcomplete-entries)))))
#+end_src

* Ediff
Just diffing. I don't have any strong opinions on it, ediff does the
job. I'm sure there are cool features I'm not aware of.

** Ignore whitespace changes
#+begin_src emacs-lisp :tangle yes
(setq ediff-diff-options "-w")
#+end_src

** Don't create a new frame for the control window
#+begin_src emacs-lisp :tangle yes
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

** Split horizontally by default
#+begin_src emacs-lisp :tangle yes
(setq ediff-split-window-function 'split-window-horizontally)
#+end_src

* Dired

** Enable find-alternate-file
This causes =RET= to open the target in the current buffer, instead of
a new buffer. As a result, when traversing directories I don't get one
buffer per step, which quickly gets annoying.

At some point I need to rebind =^= as well.

#+begin_src emacs-lisp :tangle yes
(put 'dired-find-alternate-file 'disabled nil)
#+end_src

** Always show me current data
#+begin_src emacs-lisp :tangle yes
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+end_src

* Woman
~man~ and ~woman~ are manual page readers for emacs. ~man~ just calls
the system =man= and shows the results in a buffer, while ~woman~ is a
full man page parser in Emacs Lisp. ~woman~ is much faster, but does
not support all formats of man pages. To solve this issue, I'm
patching ~woman~ to fall back to ~man~ if it fails to render, which is
still fast because it doesn't require ~man~ to build a man page index,
as we just pass it the correct file already.

#+begin_src emacs-lisp :tangle yes
(use-package man
  :straight nil
  :after (woman)
  :defer t
  :commands (woman)
  :config/el-patch
  (defun woman (&optional topic re-cache)
  "Browse UN*X man page for TOPIC (Without using external Man program).
The major browsing mode used is essentially the standard Man mode.
Choose the filename for the man page using completion, based on the
topic selected from the directories specified in `woman-manpath' and
`woman-path'.  The directory expansions and topics are cached for
speed.  With a prefix argument, force the caches to be
updated (e.g. to re-interpret the current directory).

Used non-interactively, arguments are optional: if given then TOPIC
should be a topic string and non-nil RE-CACHE forces re-caching."
    (interactive (list nil current-prefix-arg))
    ;; The following test is for non-interactive calls via gnudoit etc.
    (if (or (not (stringp topic)) (string-match-p "\\S " topic))
        (let ((file-name (woman-file-name topic re-cache)))
          (if file-name
              (el-patch-swap
                (woman-find-file file-name)
                (condition-case nil
                    (woman-find-file file-name)
                  (error (progn
                           (message "WoMan failed to format %s, falling back to `man'..." file-name)
                           (kill-buffer (alist-get file-name woman-buffer-alist))
                           (pop-to-buffer (man file-name))))))
            (message
             "WoMan Error: No matching manual files found in search path")
            (ding)))
      (message "WoMan Error: No topic specified in non-interactive call")
      (ding))))
#+end_src

* Helpful
Helpful provides better =*Help*= buffers, with niceties such as "where
is this symbol referenced", and the full source code.

#+begin_src emacs-lisp :tangle yes
(use-package helpful
  :commands (helpful-symbol helpful-key)
  :general
  (leader-def
    "h d" 'helpful-symbol
    "h f" 'helpful-function
    "h k" 'helpful-key))
#+end_src

* Esup
This allows me to benchmark Emacs startup.

#+begin_src emacs-lisp :tangle yes
(use-package esup
  :defer t
  :commands (esup))
#+end_src

* ERC
IRC. I don't use IRC a lot, but every now and then. As such I like ERC
because it works reasonably well out of the box, and I don't need to
yak shave an awful lot.

#+begin_src emacs-lisp :tangle yes
(use-package erc
  :straight nil
  :defer t
  :commands (erc sulami/erc)
  :custom
  (erc-nick "sulami")
  (erc-join-buffer 'bury)
  (erc-hide-list '("JOIN" "PART" "QUIT"))
  (erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
  (erc-rename-buffers t)
  (erc-interpret-mirc-color t)
  (erc-timestamp-only-if-changed-flag nil)
  (erc-timestamp-format "%H:%M ")
  (erc-fill-prefix nil)
  (erc-fill-function 'erc-fill-variable)
  (erc-insert-timestamp-function 'erc-insert-timestamp-left)
  (erc-autojoin-channels-alist '(("freenode.net" "#nixers_net" "#circleci")
                                 ("irc.circleci.com" "#general")))
  :config
  (add-to-list 'erc-modules 'keep-place)
  (add-to-list 'erc-modules 'spelling)
  (defun sulami/erc ()
    (interactive)
    (erc :server "irc.freenode.net"
         :port 6667
         :nick "sulami"
         :password (string-trim (shell-command-to-string "pass freenode/password")))
    (erc :server "irc.circleci.com"
         :port 6667
         :nick "robins"
         :password (string-trim (shell-command-to-string "pass circleci/irc/password"))))
  :general
  (leader-def
    "a i" 'erc-track-switch-buffer))
#+end_src

* Email
This is my email setup. I fetch email into a local maildir, which is
available offline, and also much faster.

#+begin_src emacs-lisp :tangle yes
(setq message-directory "~/.mail"
      message-kill-buffer-on-exit t
      message-send-mail-function 'message-send-mail-with-sendmail
      message-sendmail-envelope-from 'header
      sendmail-program "msmtp"
      mail-specify-envelope-from t
      mail-envelope-from 'header)
#+end_src

** Notmuch
[[https://notmuchmail.org/][notmuch]] is a performant email tagging system, which I use to sort and
view emails in my local maildir.

#+begin_src emacs-lisp :tangle yes
(use-package notmuch
  :defer t
  :custom
  (notmuch-search-oldest-first nil)
  (notmuch-always-prompt-for-sender t)
  (notmuch-mua-cite-function 'message-cite-original-without-signature)
  (notmuch-fcc-dirs '((".*@sulami.xyz" . "fastmail/Sent +sent -inbox -unread")
                      (".*@peerwire.org" . "fastmail/Sent +sent -inbox -unread")
                      ("robins@circleci.com" . "\"circleci-gmail/[Gmail]/Sent Mail\" +sent -inbox -unread")))
  :config
  (defun notmuch-inbox ()
    (interactive)
    (notmuch-search "tag:inbox" t))
  (defun notmuch-unread ()
    (interactive)
    (notmuch-search "tag:unread" t))
  :general
  (leader-def
    "m i" 'notmuch-inbox
    "m m" 'notmuch
    "m n" 'notmuch-mua-new-mail
    "m r" 'notmuch-poll
    "m s" 'notmuch-search
    "m u" 'notmuch-unread))
#+end_src

* Verb
Verb is an extension to org-mode to run HTTP requests in a literate
manner. It has all kinds of useful features to build a request library
which can be programmed.

#+begin_src emacs-lisp :tangle yes
(use-package verb
  :defer t
  :general
  (local-leader-def
    :keymaps 'org-mode-map
    "h" '(:ignore t :wk "http")
    "h s" 'verb-send-request-on-point-other-window-stay
    "h S" 'verb-send-request-on-point-other-window
    "h q" 'verb-send-request-on-point-no-window
    "h r" 'verb-re-send-request
    "h v" 'verb-set-var
    "h y" 'verb-export-request-on-point)
  (general-nmap
    :keymaps 'verb-response-body-mode-map
    "q" 'verb-kill-response-buffer-and-window))
#+end_src

* Literate Calc Mode
This is my own package, which does live inline calculations. Quite
handy, if you ask me.

#+begin_src emacs-lisp :tangle yes
(use-package literate-calc-mode
  :defer t)

#+end_src
* vterm
vterm is a terminal emulator which is way faster than anything built
into Emacs. It copes well with huge amounts of output and weird escape
sequences. Prior to installation run:

#+begin_src sh
brew install cmake libtool
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package vterm
  :defer t
  :commands (vterm)
  :general
  (leader-def
    "a t" 'vterm))
#+end_src

* Clojure
Clojure is the language I work with at =$DAYJOB=, so it has quite a
lot of configuration.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package clojure-mode
  :defer t
  :general
  (local-leader-def
    :keymaps 'clojure-mode-map
    "R" '(:ignore t :wk "refactor")
    "R a" 'clojure-align
    "R l" 'clojure-move-to-let
    "R t" 'clojure-thread-first-all
    "R T" 'clojure-thread-last-all
    "R u" 'clojure-unwind-all)
  :config
  (define-clojure-indent
    (database/speculate 1)
    (car/wcar 1)))

(use-package flycheck-clj-kondo
  :defer t
  :hook (clojure-mode . (lambda () (require 'flycheck-clj-kondo))))
#+END_SRC

** CIDER
The big IDE-like integration for Clojure.

#+begin_src emacs-lisp :tangle yes
(use-package cider
  :defer t
  :config
  (defun sulami/cider-debug-defun-at-point ()
    "Set an implicit breakpoint and load the function at point."
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'cider-eval-defun-at-point)))
  :custom
  (cider-show-error-buffer nil)
  (cider-repl-display-help-banner nil)
  (cider-redirect-server-output-to-repl nil)
  :general
  (local-leader-def
    :keymaps 'cider-mode-map
    "c" 'cider-connect
    "j" 'cider-jack-in
    "q" 'cider-quit
    "s" 'cider-scratch
    "x" 'cider-ns-reload-all
    "e" '(:ignore t :wk "eval")
    "e b" 'cider-eval-buffer
    "e d" 'sulami/cider-debug-defun-at-point
    "e e" 'cider-eval-last-sexp
    "e f" 'cider-eval-defun-at-point
    "e r" 'cider-eval-region
    "h" '(:ignore t :wk "help")
    "h a" 'cider-apropos
    "h A" 'cider-apropos-documentation
    "h d" 'cider-doc
    "h i" 'cider-inspect-last-result
    "h w" 'cider-clojuredocs
    "h W" 'cider-clojuredocs-web
    "r" '(:ignore t :wk "repl")
    "r f" 'cider-insert-defun-in-repl
    "r n" 'cider-repl-set-ns
    "r r" 'cider-switch-to-repl-buffer
    "t" '(:ignore t :wk "test")
    "t b" 'cider-test-show-report
    "t f" 'cider-test-rerun-failed-tests
    "t l" 'cider-test-run-loaded-tests
    "t n" 'cider-test-run-ns-tests
    "t p" 'cider-test-run-project-tests
    "t t" 'cider-test-run-test)
  :hook
  (cider-repl-mode . company-mode))
#+end_src

** Monroe
The smaller integration for Clojure. Sometimes less buggy.

#+begin_src emacs-lisp :tangle yes
(use-package monroe
  :disabled
  :defer t
  :config
  (defun sulami/monroe-run-test ()
    (interactive)
    (save-excursion
      (beginning-of-defun)
      (evil-forward-WORD-begin)
      (let ((test-name (symbol-name (symbol-at-point))))
        (monroe-input-sender nil (format "(%s)" test-name)))))
  (defun sulami/monroe-run-ns-tests ()
    (interactive)
    (monroe-input-sender nil "(clojure.test/test-ns *ns*)"))
  :general
  (local-leader-def
    :keymaps 'clojure-mode-map
    "c" 'monroe
    "e" '(:ignore t :wk "eval")
    "e b" 'monroe-eval-buffer
    "e f" 'monroe-eval-defun
    "e r" 'monroe-eval-region
    "r" '(:ignore t :wk "repl")
    "r n" 'monroe-eval-namespace
    "r r" 'monroe-switch-to-repl
    "t" '(:ignore t :wk "test")
    "t n" 'sulami/monroe-run-ns-tests
    "t t" 'sulami/monroe-run-test))
#+end_src

** HugSQL
HugSQL is a Clojure ORM which adds some special syntax to SQL.

This declaration is only here for config encapsulation, it doesn't
actually install a package.

In this case we install a fix to make imenu work in HugSQL files.

#+begin_src emacs-lisp :tangle yes
(use-package hugsql
  :straight nil
  :defer t
  :init
  (defun sulami/init-hugsql-imenu ()
    (when (string-suffix-p ".hug.sql" (buffer-file-name))
      (setq
       imenu-generic-expression
       '((nil "^--[[:space:]]:name[[:space:]]+\\([[:alnum:]-]+\\)" 1)))))
  :hook
  (sql-mode . sulami/init-hugsql-imenu))
#+end_src

* Common Lisp
One of my favourite recreational languages. I use =sly= instead of
=slime= because it's supposedly better. I don't have much of an
opinion, it works.

#+begin_src emacs-lisp :tangle yes
(use-package sly
  :defer t
  :commands (sly)
  :custom
  (inferior-lisp-program "sbcl")
  :general
  (local-leader-def
    :keymaps 'sly-mode-map
    "s" 'sly
    "q" 'sly-quit-lisp
    "e" '(:ignore t :wk "eval")
    "e b" 'sly-eval-buffer
    "e e" 'sly-eval-last-expression
    "e f" 'sly-eval-defun
    "e r" 'sly-eval-region
    "h" '(:ignore t :wk "help")
    "h a" 'sly-apropos
    "h d" 'sly-documentation
    "h i" 'sly-inspect))
#+end_src

* Racket
I use Racket for quite a bit of scripting, due to its rich standard
library. I don't need any fancy configuration though, the major mode
comes with reasonable defaults. This does not have the usual =eval=
bindings, because I usually don't use Racket REPLs.

#+begin_src emacs-lisp :tangle yes
(use-package racket-mode
  :defer t)
#+end_src

* Haskell
I used to write a lot more Haskell, but I still have some. The major
mode has reasonable defaults, so that's all I need for now.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package haskell-mode
  :defer t)
#+END_SRC

* Rust
I don't actually really use Rust beyond experiments, so not much
config here.

#+begin_src emacs-lisp :tangle yes
(use-package rust-mode
  :defer t)
#+end_src

* Web
#+begin_src emacs-lisp :tangle yes
(use-package web-mode
  :defer t
  :custom
  (web-mode-code-indent-offset 2)
  (web-mode-markup-indent-offset 2)
  :mode
  ("\\.tsx" . web-mode))
#+end_src

* Typescript
#+begin_src emacs-lisp :tangle yes
(use-package typescript-mode
  :defer t
  :custom
  (typescript-indent-level 2))

(use-package tide
  :defer t
  :config
  (defun sulami/tide-setup ()
    (when (equal "tsx"
                 (file-name-extension buffer-file-name))
      (tide-setup)
      (flycheck-mode +1)
      (eldoc-mode +1)))
  :hook
  ((typescript-mode . sulami/tide-setup)
   (web-mode . sulami/tide-setup)))
#+end_src
* LLVM
I look at LLVM assembly more than is healthy, and some colour helps
there. This mode is taken from the LLVM source tree and included in my
repo directly, as there's no easy way of getting it otherwise.

#+begin_src emacs-lisp :tangle yes
(load "~/.emacs/lisp/llvm-mode")
#+end_src

* Docker

#+begin_src emacs-lisp :tangle yes
(use-package dockerfile-mode
  :defer t)
#+end_src

** Docker-Tramp

Docker & tramp integration allows for using ~/docker:container~ as a
tramp target.

#+begin_src emacs-lisp :tangle yes
(use-package docker-tramp
  :defer t)
#+end_src

* Markdown
I think it's vastly inferior to org-mode, but I still have to use it.
Mostly just try to make it look & work like org-mode.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package markdown-mode
  :defer t
  :custom
  (markdown-fontify-code-blocks-natively t)
  :hook
  ((markdown-mode . orgtbl-mode)
   (markdown-mode . flyspell-mode))
  :general
  (local-leader-def
    :keymaps 'markdown-mode-map
    "l" 'markdown-insert-link
    "m" 'markdown-toggle-markup-hiding)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)))

(use-package edit-indirect
  :defer t)
#+END_SRC

* YAML
Sometimes I'm a YAML-engineer, too.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yaml-mode
  :defer t)
#+END_SRC

* Nix
#+begin_src emacs-lisp :tangle yes
(use-package nix-mode
  :defer t)
#+end_src
* Protobuf
We use quite a lot of protobuffers at =$DAYJOB=, so the mode is
useful.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package protobuf-mode
  :defer t
  :init
  (defun sulami/init-protobuf-imenu ()
    "Sets up imenu support for Protobuf.

Stolen from Spacemacs."
    (setq
     imenu-generic-expression
     '((nil "^[[:space:]]*\\(message\\|service\\|enum\\)[[:space:]]+\\([[:alnum:]]+\\)" 2))))
  :hook
  (protobuf-mode . sulami/init-protobuf-imenu))
#+END_SRC

* Done
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'emacs-startup-hook
          (lambda ()
            (let ((pkg-count (length (hash-table-keys straight--success-cache)))
                  (startup-time (float-time (time-subtract after-init-time before-init-time))))
              (message (format "Startup complete, loaded %d packages in %.2fs"
                               pkg-count
                               startup-time)))))
#+END_SRC
